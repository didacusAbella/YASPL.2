package com.didacusabella.yaspl.visitor;

import com.didacusabella.yaspl.semantic.SymbolTable;
import com.didacusabella.yaspl.syntax.*;

import java.util.List;
import java.util.StringJoiner;
import java.util.stream.Collectors;


public class CodeVisitor implements Visitor<String, SymbolTable> {

    private static final String C_HEADER = "#include <stdio.h>\n" +
            "#include <stdbool.h>\n";

    private static final String COMMENT_HEADER = "/*This file was generated by yasplcc*/";
    private static final String DECL_HEADER = "/***********Declarations***********/";
    private static final String MAIN_HEADER = "/***********Main*******************/";

    public CodeVisitor()  {
        super();
    }

    @Override
    public String visit(Program programNode, SymbolTable param) {
        String decls = compactCode(programNode.getDeclarations(), param);
        String stmts = compactCode(programNode.getStatements(), param);
        return String.format("%s\n%s\n%s\n%s\n%s\nint main(){%s\n return 0;\n}\n", COMMENT_HEADER,
                C_HEADER, DECL_HEADER, decls,MAIN_HEADER,stmts);
    }

    @Override
    public String visit(VariableDeclaration variableDeclarationNode, SymbolTable param) {
        String type = variableDeclarationNode.getType().accept(this, param);
        StringJoiner variableJoiner = new StringJoiner(", ", type.concat(" "), ";\n");
        variableDeclarationNode.getVariables().forEach(v -> variableJoiner.add(v.accept(this, param)));
        return variableJoiner.toString();
    }

    @Override
    public String visit(FunctionDeclaration functionDeclarationNode, SymbolTable param) {
        String funcName = functionDeclarationNode.getIdentifier().accept(this, param);
        String input = "";
        if(!functionDeclarationNode.getVariableDeclarations().isEmpty()){
            StringJoiner functionJoiner = new StringJoiner(", ");
            functionDeclarationNode.getVariableDeclarations().forEach(vd -> {
                vd.getVariables().forEach(v -> {
                    functionJoiner.add(String.format("%s %s", vd.getNodeType().getValue(),
                            v.accept(this, param)));
                });
            });
            input = functionJoiner.toString().concat(", ");
        }
        String output = this.joiningCode(functionDeclarationNode.getParameterDeclarations(), param);
        String body = functionDeclarationNode.getBody().accept(this, param);
        return String.format("void %s(%s%s){\n%s\n}\n\n", funcName, input, output, body);
    }

    @Override
    public String visit(Variable variableNode, SymbolTable param) {
        return variableNode.getIdentifier().accept(this, param);
    }

    @Override
    public String visit(Type typeNode, SymbolTable param) {
        return typeNode.getTypeName();
    }

    @Override
    public String visit(Identifier identifierNode, SymbolTable param) {
        return identifierNode.getName();
    }

    @Override
    public String visit(ParameterDeclaration parameterDeclarationNode, SymbolTable param) {
        StringJoiner outputJoiner = new StringJoiner(", ");
        parameterDeclarationNode.getVariableDeclarationList().forEach(vd -> {
            vd.getVariables().forEach(v -> {
                outputJoiner.add(String.format("%s *%s", vd.getNodeType().getValue(), v.accept(this, param)));
            });
        });
        return outputJoiner.toString();
    }

    @Override
    public String visit(Body bodyNode, SymbolTable param) {
        String vardecl = compactCode(bodyNode.getVariableDeclarationList(), param);
        String stmts = compactCode(bodyNode.getStatements(), param);
        return String.format("%s\n%s\n", vardecl, stmts);
    }

    @Override
    public String visit(ReadStatement readStatementNode, SymbolTable param) {
        StringJoiner type = new StringJoiner(", ");
        readStatementNode.getTypeList().forEach(t -> type.add(mapType(t.accept(this, param))));
        StringJoiner inputs = new StringJoiner(", ");
        readStatementNode.getIdentifierList().forEach(i -> inputs.add("&".concat(i.accept(this, param))));
        return String.format("scanf(\"%s\", %s);\n", type.toString(), inputs.toString());
    }

    @Override
    public String visit(WriteStatement writeStatementNode, SymbolTable param) {
        StringJoiner output = new StringJoiner(", ");
        StringJoiner types = new StringJoiner(", ");
        writeStatementNode.getExpressions().forEach(e -> {
            types.add(mapType(e.getNodeType().getValue()));
            output.add(e.accept(this, param));
        });
        return String.format("printf(\"%s\", %s);\n", types.toString(), output.toString());
    }

    @Override
    public String visit(FunctionCall functionCallNode, SymbolTable param) {
        String functionName = functionCallNode.getFunctionName().accept(this, param);
        String input = "";
        if(!functionCallNode.getExpressions().isEmpty()){
            StringJoiner sj = new StringJoiner(", ");
            functionCallNode.getExpressions().forEach(e -> sj.add(e.accept(this, param)));
            input = sj.toString().concat(",");
        }
        StringJoiner output = new StringJoiner(", ");
        functionCallNode.getVariableList().forEach(v -> output.add("&".concat(v.accept(this, param))));
        return String.format("%s(%s%s);\n", functionName, input, output);
    }

    @Override
    public String visit(CompositeStatement compositeStatementNode, SymbolTable param) {
        return compactCode(compositeStatementNode.getStatementList(), param);
    }

    @Override
    public String visit(WhileStatement whileStatementNode, SymbolTable param) {
        String condition = whileStatementNode.getWhileCondition().accept(this, param);
        String statements = whileStatementNode.getWhileStatement().accept(this, param);
        return String.format("while(%s){\n%s}\n", condition, statements);
    }

    @Override
    public String visit(IfThenStatement ifThenStatementNode, SymbolTable param) {
        String idCondition = ifThenStatementNode.getIfCondition().accept(this, param);
        String statements = ifThenStatementNode.getThenStatement().accept(this, param);
        return String.format("if(%s){\n%s}\n", idCondition, statements);
    }

    @Override
    public String visit(IfThenElseStatement ifThenElseStatementNode, SymbolTable param) {
        String idCondition = ifThenElseStatementNode.getIfCondition().accept(this, param);
        String statements = ifThenElseStatementNode.getThenStatement().accept(this, param);
        String elseCondition = ifThenElseStatementNode.getElseStatement().accept(this, param);
        return String.format("if(%s){\n%s}else{\n%s}\n", idCondition, statements, elseCondition);
    }

    @Override
    public String visit(BinaryExpression binaryExpressionNode, SymbolTable param) {
        String left = binaryExpressionNode.getLeftOperand().accept(this, param);
        String right = binaryExpressionNode.getRightOperand().accept(this, param);
        String operand = mapOperand(binaryExpressionNode.getOp());
        return String.format("%s %s %s", left, operand, right);
    }

    @Override
    public String visit(UminusExpression uminusExpressionNode, SymbolTable param) {
        return String.format("-%s", uminusExpressionNode.getExpression().accept(this, param));
    }

    @Override
    public String visit(DoubleConst doubleConstNode, SymbolTable param) {
        return String.valueOf(doubleConstNode.getDoubleValue());
    }

    @Override
    public String visit(IntegerConst integerConstNode, SymbolTable param) {
        return String.valueOf(integerConstNode.getIntValue());
    }

    @Override
    public String visit(StringConst stringConstNode, SymbolTable param) {
        return "\"".concat(stringConstNode.getStringValue()).concat("\"");
    }

    @Override
    public String visit(NotExpression notExpressionNode, SymbolTable param) {
        return String.format("!(%s)", notExpressionNode.getExpression().accept(this, param));
    }

    @Override
    public String visit(TrueExpression trueExpressionNode, SymbolTable param) {
        return String.valueOf(trueExpressionNode.getValue());
    }

    @Override
    public String visit(FalseExpression falseExpressionNode, SymbolTable param) {
        return String.valueOf(falseExpressionNode.getValue());
    }

    @Override
    public String visit(RelationalExpression relationalExpressionNode, SymbolTable param) {
        String left = relationalExpressionNode.getLeftOperand().accept(this, param);
        String right = relationalExpressionNode.getRightOperand().accept(this, param);
        String op = mapOperand(relationalExpressionNode.getRelOp());
        return String.format("%s %s %s", left, op, right);
    }

    @Override
    public String visit(AssignStatement assignStatementNode, SymbolTable param) {
        String ident = assignStatementNode.getIdentifier().accept(this, param);
        String value = assignStatementNode.getExpression().accept(this, param);
        return String.format("%s = %s;\n", ident, value);
    }

    private String compactCode(List<? extends YasplNode> list, SymbolTable st){
        return list.stream().map(l -> l.accept(this, st)).reduce("", String::concat);
    }

    private String joiningCode(List<? extends YasplNode> list, SymbolTable st){
        return list.stream().map(l -> l.accept(this, st)).collect(Collectors.joining(", "));
    }


    private static String mapType(String type){
        switch(type){
            case "bool": case "int":
                return "%d";
            case "double":
                return "%lf";
            case "string":
                return "%s";
                default:
                    return "%d";
        }
    }

    private static String mapOperand(String op){
        switch(op){
            case "PLUS":
                return "+";
            case "MINUS":
                return "-";
            case "TIMES":
                return "*";
            case "DIV":
                return "/";
            case "GT":
                return ">";
            case "LT":
                return "<";
            case "GE":
                return ">=";
            case "LE":
                return "<=";
            case "EQ":
                return "==";
            case "AND":
                return "&&";
            case "OR":
                return "||";
                default:
                    return "";
        }
    }

}
