/*
   YASPL.2 Grammar
*/
package com.didacusabella.yaspl.dist;
import java_cup.runtime.*;
import java.util.ArrayList;
import com.didacusabella.yaspl.syntax.*;
import com.didacusabella.yaspl.visitor.*;

/* Terminals (tokens returned by the scanner). Annotated with String attribute. Exception for constants */
terminal String        HEAD, START, SEMI, INT, BOOL, DOUBLE, NAME, COMMA, DEF, LPAR, RPAR, COLON, LGPAR,
                       RGPAR, READ, WRITE, PLUS, MINUS, TIMES, DIV,  ASSIGN, IF, THEN, ELSE, WHILE, DO,
                       GT, GE, LT, LE, EQ, NOT, AND, OR, STRING, UMINUS;
terminal Integer INT_CONST;
terminal Double DOUBLE_CONST;
terminal String STRING_CONST;
terminal Boolean TRUE, FALSE;

/* Non terminals. Each non terminal is annotated with a class */
non terminal Program Programma;
non terminal VariableDeclaration Var_decl;
non terminal Type Type;
non terminal FunctionDeclaration Def_decl;
non terminal Body Body;
non terminal CompositeStatement Comp_stat;
non terminal Statement Stat, Simple_stat;
non terminal Expression Expr;
non terminal BooleanExpression Bool_Expr;
non terminal ArrayList<ParameterDeclaration> Par_decls;
non terminal ArrayList<Decl> Decls;
non terminal ArrayList<Statement> Statements;
non terminal ArrayList<Variable> Vars;
non terminal ArrayList<Type> Types;
non terminal ArrayList<Expression> Out_values;
non terminal ArrayList<Expression> Exprs;
non terminal ArrayList<VariableDeclaration> Var_decls;
non terminal ArrayList<Expression> Def_Expr;
non terminal String Arith_op, Bool_op, Rel_op;

/* Precedences. C style */
precedence left COMMA;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence left TIMES, DIV;
precedence left PLUS, MINUS;
precedence right NOT;

/*------------------------------------------- START GRAMMAR--------------------------------------------------*/

/********************************** Entrypoint of the Program *****************************************/
Programma ::= HEAD Decls:decls START Statements:stmts
            {:
                RESULT = new Program(decls, stmts);
                SyntaxVisitor visitor = new SyntaxVisitor();
                visitor.appendRoot(visitor.visit(RESULT, null));
                visitor.toXml();
            :};


/***************************************** Declarations ***********************************************/
Decls  ::=  Var_decl:var_decl Decls:decls {: decls.add(var_decl); RESULT = decls; :}
          | Def_decl:def_decl Decls:decls {: decls.add(def_decl); RESULT = decls; :}
          | {: RESULT = new ArrayList<>(); :} //empty production
          ;


/********************************** Statements ********************************************************/
Statements ::= Stat:s Statements:stmts {: stmts.add(s); RESULT = stmts ; :}
              | Stat:s {: RESULT = new ArrayList<>(); RESULT.add(s); :}
              ;


/********************************** Variable Declarations *******************************************/
Var_decl ::= Type:type Vars:vars SEMI{: RESULT = new VariableDeclaration(type, vars); :};


/************************************ Types ammitted ************************************************/
Type ::=  INT {: RESULT = new Type("integer"); :}
        | BOOL {: RESULT = new Type("boolean"); :}
        | DOUBLE {: RESULT = new Type("double");:}
        | STRING {: RESULT = new Type("string"); :}
        ;


/***************************************** Variables ***********************************************/
Vars ::= NAME:name COMMA Vars:vars {: vars.add(new Variable(new Identifier(name))); RESULT = vars; :}
        | NAME:name {: RESULT = new ArrayList<>(); RESULT.add(new Variable(new Identifier(name))); :}
        ;


/***************************************** Type set ***********************************************/
Types ::= Type:type COMMA Types:types {: types.add(type); RESULT = types; :}
         | Type:type {: RESULT = new ArrayList<>(); RESULT.add(type); :}
         ;


/********************************** Function Declaration *****************************************/
Def_decl ::= DEF NAME:fname LPAR Var_decls:decls RPAR COLON Par_decls:pars Body:body
            {:
                RESULT = new FunctionDeclaration(new Identifier(fname), decls, pars, body);
            :}
            ;


/********************************** Variable Declarations *****************************************/
Var_decls ::= Var_decl:vd Var_decls:vds {: vds.add(vd); RESULT = vds; :}
             | {: RESULT = new ArrayList<>(); :}//empty production
             ;


/************************************ Function Parameter *****************************************/
Par_decls ::= Var_decl:vd Par_decls:pd {: pd.add(new ParameterDeclaration(vd)); RESULT = pd; :}
             | Var_decl:vd {: RESULT = new ArrayList<>(); RESULT.add(new ParameterDeclaration(vd)); :}
             ;


/************************************ Body Program **********************************************/
Body ::= LGPAR Var_decls:vds Statements:stmts RGPAR SEMI {: RESULT = new Body(vds, stmts); :} ;


/********************************** Composite Statement *****************************************/
Comp_stat ::= LGPAR Statements:stmts RGPAR {: RESULT = new CompositeStatement(stmts); :} ;


/**************************************** Statement ********************************************/
Stat ::= Comp_stat:cs {: RESULT = cs; :}
       | Simple_stat:ss {: RESULT = ss; :}
       ;


/********************************** Simple Statement *******************************************/
Simple_stat ::=  Vars:vs READ Types:tps SEMI {: RESULT = new ReadStatement(vs, tps); :}
               | Out_values:ov WRITE SEMI {: RESULT = new WriteStatement(ov); :}
               | NAME:name ASSIGN Expr:expr SEMI {: RESULT = new AssignStatement(new Identifier(name), expr); :}
               | NAME:name LPAR Def_Expr:de COLON Vars:vs RPAR SEMI
                        {:
                        RESULT = new FunctionCall(new Identifier(name), de, vs);
                        :}
               | IF LPAR Bool_Expr:be RPAR THEN Comp_stat:c1 ELSE Comp_stat:c2 SEMI
                {:
                    RESULT = new IfThenElseStatement(be, c1, c2);
                :}
               | IF LPAR Bool_Expr:be RPAR THEN Comp_stat:c1 SEMI {: RESULT = new IfThenStatement(be, c1); :}
               | WHILE LPAR Bool_Expr:be RPAR DO Comp_stat:c1 SEMI {: RESULT = new WhileStatement(be, c1); :}
               ;


/********************************** Input/Output *********************************************/
Out_values ::=  Expr:exp COMMA Out_values:ov {: ov.add(exp); RESULT = ov; :}
              | STRING_CONST:sc COMMA Out_values:ov {: ov.add(new StringConst(sc)); RESULT = ov; :}
              | Expr:exp {: RESULT = new ArrayList<>(); RESULT.add(exp); :}
              | STRING_CONST:sc {: RESULT = new ArrayList<>(); RESULT.add(new StringConst(sc)); :}
              ;


/********************************** Function Parameters *****************************************/
Def_Expr ::= Exprs:exprs {: RESULT = new ArrayList<>(); RESULT.addAll(exprs); :}
            | {: RESULT = new ArrayList<>(); :}//empty
            ;


/************************************** Expressions ********************************************/
Exprs ::= Expr:exp COMMA Exprs:exprs {: exprs.add(exp); RESULT = exprs; :}
         | Expr:exp {: RESULT = new ArrayList<>(); RESULT.add(exp); :}
         ;


/************************************** Expression ********************************************/
Expr ::= INT_CONST:ic {: RESULT = new IntegerConst(ic); :}
        | DOUBLE_CONST:dc {: RESULT = new DoubleConst(dc); :}
        | Expr:s1 Arith_op:op Expr:s2 {: RESULT = new BinaryExpression(s1, s2, op); :}
        | NAME:name {: RESULT = new Identifier(name);:}
        | MINUS Expr:exp {: RESULT = new UminusExpression(exp); :} %prec UMINUS
        | LPAR Expr:expr RPAR {: RESULT = expr; :}
        ;


/********************************** Arithmetical Operation *****************************************/
Arith_op ::= PLUS:s {: RESULT = "PLUS"; :}
            | MINUS:s {:RESULT = "MINUS"; :}
            | TIMES:s {:RESULT = "TIMES"; :}
            | DIV:s {:RESULT = "DIV"; :}
            ;


/********************************** BooleanExpression *****************************************/
Bool_Expr ::= TRUE {: RESULT = new TrueExpression(); :}
             | FALSE {: RESULT = new FalseExpression(); :}
             | Bool_Expr:b1 Bool_op:bo Bool_Expr:b2 {: RESULT = new RelationalExpression(b1, b2, bo); :}
             | NOT Bool_Expr:exp {: RESULT = new NotExpression(exp); :}
             | Expr:r1 Rel_op:ro Expr:r2 {: RESULT = new RelationalExpression(r1, r2, ro);:}
             | LPAR Bool_Expr:be RPAR {: RESULT = be; :}
             ;


/********************************** BooleanOperation *****************************************/
Bool_op ::= AND:bo {: RESULT = "AND"; :}
           | OR:bo {: RESULT = "OR"; :}
           ;


/********************************** Relational Operations *****************************************/
Rel_op ::=  GT:ro {: RESULT = "GT"; :}
          | GE:ro {: RESULT = "GE"; :}
          | LT:ro {: RESULT = "LT"; :}
          | LE:ro {: RESULT = "LE"; :}
          | EQ:ro {: RESULT = "EQ"; :}
          ;

/*------------------------------------------- END GRAMMAR--------------------------------------------------*/